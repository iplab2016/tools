#!/usr/bin/python
#coding=utf-8
"""Evaluate the performance of Linux Traffic Control (TC)

author:   melonli
date:     2016.11.27
"""

import sys
import os
import time
import socket
import argparse
import atexit
import signal
import threading

def readable_size(bytes):
    b = int(bytes)
    if b < 1024: return str(b)+"B"
    if b < 1024*1024: return ("%.2f" % (b/1024.0))+"KB"
    if b < 1024*1024*1024: return ("%.2f" % (b/1024.0/1024))+"MB"
    if b < 1024*1024*1024*1024: return ("%.2f" % (b/1024.0/1024/1024))+"GB"
    return ("%.2f" % (b/1024.0/1024/1024/1024))+"TB"

def is_ip(ip):
    q = ip.split('.')
    return len(q) == 4 and len(filter(lambda x: x >= 0 and x <= 255, \
        map(int, filter(lambda x: x.isdigit(), q)))) == 4

def init_parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', '--client', type=str,
          help="[ping] Server") 
    parser.add_argument('-s', '--server', type=str,
          help="[start] Server") 
    parser.add_argument('-v', '--verbose', type=int, choices=[0, 1],default=0,
          help="verbose, 1 stands for verbose, 0 not") 
    parser.add_argument('-t', '--timeout', type=int, default=2,
          help="Time to wait for a response, in seconds.") 
    parser.add_argument('--ip', default="127.0.0.1",type=str, 
          help="Server ip(client requests to this ip), default ip 127.0.0.1.") 
    parser.add_argument('--port',default="1989", type=int,
          help="Server port(client requests to this port), default port 1989.") 
    parser.add_argument('--cnt',default="3", type=int,
          help="count, Stop after sending count ECHO_REQUEST packets.") 
    parser.add_argument('--size',default="56", type=int,
          help="packetsize,Specifies the number of data bytes to be sent.") 

    return parser


class Server():
    """The Server listening for UDP Client.

    Attributes:
        ip: The ipv4 address for staring server in local host. 
        port: The port of the ip address.
    """

    def __init__(self, ip, port, verbose):
        self.addr = (ip, port)
        self.server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server.bind(self.addr)

    def run(self):
        s = self.server
        print "Starting Server at %s %d" % self.addr
        print "Listening for Client"
        while True:
            buf, addr = s.recvfrom(1500)
            print 'Received from %s:%s' % addr
            s.sendto(buf, addr)
    

class Client():
    """The UDP Client.

    Attributes:
        ip: The ipv4 address of  server in remote host. 
        port: The port of the remote server.
        cmd: The command string.
        verbose: If verbose is 1, print debug information;otherwise not.
    """

    def __init__(self, ip, port, cmd, verbose, count=3, size=56, timeout=2):
        self.addr = (ip, port)
        self.cmd = cmd
        self.count = count
        self.size = size
        self.v = verbose
        self.timeout = timeout
        self.failed = 0
        self.succeeded = 0 
        # Dictory Type,{seq(int): sending_timestamp(float)}
        self.times = {}
        self.client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    def ping_send(self, count=3, size=56):
        """Send the simulating ping packets by socket udp."""
        cnt = 0
        print("PING %s (%s) %d(%d) bytes of data" %
              (self.addr[0], 
               self.addr[0],
               size,
               size+8,
              ))
        while cnt < count:
            cnt = cnt + 1
            c = self.client
            info = "Succeeded to send ping"
            try:
                p = self.assemble_pingpacket(cnt, size)
                c.sendto(p, self.addr)
                self.times[cnt] = time.time()
            except:
                self.failed = self.failed + 1
                info = "Failed to send ping"
            if self.v: print info
            time.sleep(1)

    def ping_rec(self, timeout=2):
        """Receive the response of ping.
        
        Args:
            timeout: int. Time to wait for a response, in seconds.
        """
        ts = time.time()
        while True:
            failed = 0
            info,addr = self.client.recvfrom(self.size+30)
            te = time.time()
            if self.v: print("The infor received from %s: %s" %(addr[0],info))
            if info:
                if info[0] == "#" and info[-1] == "$":
                    pos = info.find("_", 2)
                    if pos > 2: 
                        cnt = info[2:pos]
                    else:
                        failed = 1
            else:
                failed = 1

            if failed == 1: 
                if te-ts > timeout: break
                ts = te
                continue

            ts = te
            self.succeeded = self.succeeded + 1    
            print("%d bytes from %s: icmp_seq=%s time=%.2f ms" % 
                  (len(info), self.addr[0], cnt, float(te-self.times[int(cnt)])*1000))
            if int(cnt) >= self.count: break

    def assemble_pingpacket(self, seq, size):
        """Assemble packet for ping function.

        Assembling Format: #_seq_seq_...seq_$. 
        
        Args:
            seq: int, the sequence of performing ping function.
            size: int, the size of the packet load. 
                 Its value must be larger than len(seq)+ 4.

        Returns:
            The packet string, if failed raise error.
       
        Raises:
            ASSEMBLE_FAILURE: failed to assemble ping packet
        """    
        seq = str(seq)
        if size < (len(seq) + 4):
            if self.v: print("The packet size is less than len(seq) + 4")
            raise Exception("ASSEMBLE_FAILURE")

        l = len(seq) + 1
        cnt = (size - 3)/l 
        left = (size - 3)%l

        buf = ['#']
        buf.extend([seq]*cnt)
        p = "_".join(buf)
        p = p + "_"*(left + 1) + "$"
        if self.v: print p
        return p 
        
    def run(self):
        cmd = self.cmd
        if cmd == "ping":
            ts = time.time()
            s = threading.Thread(target=self.ping_send, args=(self.count, self.size))
            c = threading.Thread(target=self.ping_rec, args=(self.timeout,))
            s.start()
            c.start()
            s.join()
            c.join()
            te = time.time()
            print("--- %s ping statistics ---" % self.addr[0])
            print("%d packets transmitted, %d received, %.2f%% packet loss, time %.2f ms"  %
                  (self.count, 
                   self.succeeded, 
                   (float(self.count-self.succeeded)/self.count),
                   (te-ts)
                  ))
        else:
           if self.v: 
               print("Error:The option is not supported in Client class.") 
           raise Exception("UNSUPPORTED_OPTION")

    def __del__(self):
        self.client.close()

def main():
    parser = init_parse_args()
    args = parser.parse_args()
    ip = args.ip
    port = args.port
    c = args.client
    s = args.server
    v = args.verbose
    cnt = args.cnt
    size = args.size
    timeout = args.timeout
    if not is_ip(ip): 
        print "Error:IP address Format is wrong!"
        parser.print_help()
        sys.exit(1)

    cmd = ""
    if c:
        prog = Client(ip, port, c, v, cnt, size, timeout)
        try:
            prog.run()
        except:
            parser.print_help()
            sys.exit(1)
    elif s:
        prog = Server(ip, port, v)
        prog.run() 
    else:
        parser.print_help()
        sys.exit(1)
    
    sys.exit(0)
if __name__ == '__main__':
    sys.exit(main())

